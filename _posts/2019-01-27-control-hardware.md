---
title: 02\. 하드웨어 제어
categories:
    - 임베디드 프로그래밍 C코드 최적화
tags:
    - memory map
    - 비트연산
toc: true
toc_label: "Contents"
toc_icon: "cog"
toc_sticky: true
---
임베디드 환경에서는 시스템에서 사용되는 주변기기가 모두 다르게 수정되어 있어서 공통적인 기능을 제공하는
함수를 만들기가 어렵다.  

따라서 하드웨어를 제어하는 코드를 **직접** 만들어야 한다.  

마이크로 프로세서는 주변장치를 메모리로 인식한다.  
LED, LCD, UART같은 주변 입출력 장치들을 단순히 메모리처럼 다룬다.  

다시말해, 주변 장치에 데이터를 보내거나 주변장치로부터 데이터를 받을 때는 마치 메모리에 읽거나 쓰는 것처럼
처리한다.  

따라서 처리하기 훨씬 간편하지만 메모리 공간을 주변장치가 차지하고 있으니, 그만큼 메모리에 접근할 때
조심해야한다.  

입출력 장치를 제어하는 방법에는 **메모리 맵 I/O**와 **맵 I/O** 방법이 있다.  

### 메모리 맵 I/O
- 입출력 장치들이 사용하는 메모리가 **따로 정해져 있지 않아**서 장치가 사용할 메모리를 개발자가 직접
지정하여 사용하는 방법.  
- ARM계열 프로세서들은 메모리 맵 I/O을 사용한다.  

### I/O 맵 I/O
- 입출력 장치들이 사용하는 메모리가 **미리 정해져 있어**서 지정된 메모리를 사용하는 방법.  
- PXA255같은 인텔계열 프로세서는 맵 I/O를 사용한다.  

## 하드웨어에 접근하기
마이크로 프로세서 입장에서 보면 외부에서 데이터가 입력되거나 외부로 데이터를 출력하는 과정이며,
이러한 입출력을 중간에서 연결 지어주는것이 바로 입출력 포트이다.  

그러므로 프로그램에서는 입출력 포트에서 사용할 메모리를 지정하고, 지정된 메모리에 값을 읽거나 쓰면 된다.
데이터 시트는 보드를 구성하는 하드웨어와 마이크로프로세서를 제어하는 정보들을 담고 있다.  

특히, 어떤 장치를 사용하려면 어떤 레지스터를 등록해야 하고, 어떤 값을 써야하는지에 대한 정보를 제공한다.
다음은 삼성 S3C2440A 마이크로프로세서의 데이터 시트의 일부이다.  

<sub>PORT E CONTROL REGISTERS (GPECON, GPEDAT, GPEUP)</sub>  

| Register | Address | R/W | Description | Reset Value |
|:---:|:---:|:---:|:---:|:---:|
| GPECON | `0x56000040` | R/W | Configures the pins of port E | `0x0` |
| GPEDAT | `0x56000044` | R/W | The data register for port E | `Undef.` |
| GPEUP | `0x56000048` | R/W | Pull-up disable register for port E | `0x0000` |
| reserved | `0x5600004c` | - | - | - |  

| RPECON | Bit | Description |
|:---:|:---:|:---:|
| GPE15 | [31:30] | 00=Input, 01=Output, 10=IICSDA, 11=Reserved, This pad is open-drain, There is no Pull-up option. |
| GPE14 | [29:28] | 01=Output, 10=IICSDA, 11=Reserved, This pad is open-drain, There is no Pull-up option. |
| GPE13 | [27:26] | 00=Input, 01=Output, 10=SPICLK0, 11=Reserved |
| GPE12 | [25:24] | 00=Input, 01=Output, 10=SPIMOSI0, 11=Reserved |

위 표는 입출력 포트(I/O port) 중의 하나인 GPE포트를 사용하기 위한 레지스터 정보이다.  

S3C2440A에서 입출력 포트로 사용하기 위해서는 CON 레지스터와 DAT 레지스터를 사용해야한다.  

CON 레지스터는 포트를 사용하기 위한 설정 값들이 저장되는 레지스터이고 DAT레지스터는 입출력 장치로부터
데이터를 읽고 쓸수 있는 레지스터이다.  

GPECON 레지스터는 메모리 `0x5600_0040`번지를 사용하고 GPE 포트를 입력, 출력, 특수용도 모드로
설정할 수 있다.  

GPEDAT 레지스터는 데이터가 들어갈 메모리이며 주소는 `0x5600_0044`번지이다.  

이러한 레지스터를 사용하려면 먼저 레지스터가 사용할 메모리를 선언해야 한다.  

하드웨어에 접근하려면 하드웨어에서 사용하는 메모리를 선언해서 메모리에 접근할 수 있는 방법을 만들어주어야 한다.  

## 하드웨어 제어
하드웨어를 제어하는 방법은 간단하다.  

사용할 포트를 어떤 모드로 사용할 지 설정하고, 프로그램에서 데이터 레지스터에 값을 쓰거나 읽어보면 된다.  

위 삼성 S3C2440A 마이크로프로세서의 데이터 시트를 다시 살펴봤을 때, GPECON 레지스터는 모드 설정을 위해 사용된다.  

만약 GPE15 포트를 출력으로 설정한다면 GPECON 레지스터의 [31:30] 비트에 01을 쓴다.  

GPECON 레지스터는 모드 설정을 위해 사용된다.  

GPECON [31:30] 이라는 표기는 GPECOM 레지스터가 사용하능 32비트 메모리 중에서 31, 30번 비트를 말하며,
이 위치에 데이터 시트에서 지정한 값을 쓴다.  

그리고 GPE15 포트의 데이터를 읽거나 쓰려면 GPEDAT 레지스터의 15번 비트를 사용한다.  

만약 GPECON 레지스터에서 입력으로 설정했다면 GPEDAT 레지스터의 15번 비트를 읽을 수 있고,
출력으로 설정했다면 15번 비트에 쓸 수 있다.  

## 특정 비트 제어하기
장치의 레지스터를 다룰 때에 조심할 점은 다른 비트의 값은 변경하지 않고 해당 비트만 수정해야 한다.  

다른 비트는 다른 포트에서 사용하는 메모리이므로 전체를 0으로 클리어한다면 다른 포트를 위한
설정 값이나 데이터들이 모두 삭제 되기 때문이다.  

레지스터의 특정 비트를 제어하는 것은 주로 비트 연산이 사용된다.  

다음은 하드웨어 제어에 아주 유용하게 활용할 수 있는 기본 룰 이다.  

### 특정 비트 설정과 클리어
특정 비트를 `1` 로 설정하려면 지정된 위치의 비트를 `1` 과 `|` (OR) 연산한다.  

5번 비트를 `1` 로 설정하려면 소스(source) 데이터의 값에 상관없이 `0x0010_0000`과 `|` 연산한다.  

`1` 과의 `|` 연산은 항상 결과가 `1` 이기 때문이다.  

그리고 나머지 비트는 `0` 과 `|` 연산을 취하여 원래의 값을 그대로 유지한다.  

예를 들어, 변수 a에 정수 `0x01010101`가 저장되어 있고, 이중 5번 비트를 `1` 로 설정하려면 다음과 같이 연산한다.  

#### 1. 5번 비트를 1로 설정
\\[
    \ \ \ \ \ \ \ 01010101 \\\
    or\ \ \ 00100000 \\\
    ----------------\\\
    \ \ \ \ \ \ \ 01110101
\\]

#### 2. 2번 비트를 0으로 설정
\\[
    \ \ \ \ \ \ \ \ \ \ 01010101 \\\
    and\ \ \ 11111011 \\\
    ----------------\\\
    \ \ \ \ \ \ \ \ \ \ 01010001
\\]

1번 연산을 코드화 한다면

```c
a |= 0x00100000;
```

그런데 `0x0010_0000`은 `0x1(0x0000_0001)`을 5번 왼쪽 쉬프트한 값과 같으므로 `0x1<<5`와 같이
표현할 수 있다.

그래서 수식으로 고쳐보면 다음과 같다.
```c
a |= 0x1<<5;
```

한번에 여러 비트 설정도 가능하다. 5,3,2번 비트를 1로 설정하려면
```c
a |= (0x1<<5)+(0x1<<3)+(0x1<<2);
```

와 같이 표현가능하다. 그런데 3, 2번 비트는 연속된 비트이기 때문에 `0x3`으로 묶어줄 수 있다. 그래서
```c
a |= (0x1<<5)+(0x3<<3);
```

와 같이 코드를 정리할 수 있다.

특정 비트 클리어는 지정된 비트를 `0` 과 `&` 연산함으로써 수행한다.  

특정비트를 `1` 로 설정할 때와 마찬가지로 `0` 을 원하는 위치까지 쉬프트하여 `&` 연산하고,
나머지 비트들은 `1` 과 `&` 연산으르 취하여 원래의 값으로 그대로 유지한다.  

그런데 한가지 문제가 있는데, `0x0000` 도 `0x0` 도 모두 `0` 이기 때문에 `0` 으로 자릿수를 표현할
수 없다는 것이다.  

그래서 `1` 을 원하는 위치로 쉬프트하고 그 값에 대해 `~` (NOT)연산을 해서 `0` 으로 만든다.
```c
0x1<<5     0x0010_0000
~(0x1<<5)  0x1101_1111
```

위의 2번 연산과 같이 2번 비트를 `0` 으로 클리어하려면 소스 데이터에 `0x11111011` 를 `&` 연산해야
하므로,  
```c
a &= ~(0x1<<2);
```
와 같이 표현한다.  
한번에 여러 비트 클리어도 가능한데, 5, 3, 2번 비트를 클리어 하려면  
```c
a &= ~((0x1<<5)+(0x3<<3));
```
와 같이 표현한다.  

### 특정 비트 반전
반전시키고자 하는 비트는 `1`과 `^`연산한다.  

`^` 연산은 두 피연산자가 같으면 `0` 으로, 달면 `1` 로 설정한다.  

그래서 `1^1=0` 이고 `0^1=1` 이 되므로, 원래의 비트는 `1` 과 `^` 연산 함으로써 반전된다.  

예로 5번 비트를 반전시키려면,
```c
a ^= 0x1<<5;
```
와 같이 표현한다. 한번에 5, 3, 2번 비트를 반전하려면  
```c
a ^= (0x1<<5)+(0x3<<2);
```
와 같이 표현한다.  

### 비트 검사
특정 비트가 0인지 1인지 검사하는 방법인다.  

예를 들어 5번쨰 비트가 0인지 1인지 검사할 때는 다음 수식을 이용할 수 있다.  
```c
a & (0x1<<5)
```

### 비트 추출
특정 비트만 추출하는 방법이다. 예를 들어 `[6:4]` 비트만 추출하고 싶다면 다음 수식을 이용할 수 있다.  
```c
a & 0x7
```

### 비트 연산의 활용
비트 연산을 으용하면 복잡한 로직도 비교적 짧은 코드로 만들 수 있다.  

예를 들어 값을 무조건 4의 배수로 만들어야 하는 경우가 있다고 가정하자.  

시작 값이 100이라고 하면 1을 더해도 4의 배수인 104로 증가해아한다.  

즉 정수를 더한 결과가 4의 배수가 아니라면 그보다 큰 가장 가까운 4의 배수로 값을 늘려주는 것이다.  

다음을 확인해보자.  
```c
start = 100;
scanf("%d", &x);
start += x;
if ((start % 4) == 1)
    start += 3;
else if ((start % 4) == 2)
    start += 2;
else if ((start % 4) == 3)
    start += 1;
```

start에 입력 받은 값을 더한 결과값을 `% 4`로 계산한다. 이 결과값이 1이면 3을, 
2이면 2를, 3이면 1을 더해서 4의 배수로 만들어준다.  

그럼 다음 코드를 살펴보면,
```c
start += x;
start += 0x3;
start &= ~(0x3);
```

비트 연산을 활용하여 7줄로 표현된 것을 3줄로 줄였다. x 값을 더해주고 무조건 3을 더해주고 마지막
2비트를 클리어한다.
그러면 마지막 2비트는 무조건 올림이 된다.  

이렇게 비트연산을 활용하면 복잡한 로직을 비교적 짧은 코드로 구현할 수 있다.  

### 비트 연산을 편하게
비트 연산은 임베디드 소프트웨어에서는 자주 사용되는 연산이기 때문에 확실히 이해해야 하는 주요요한 부분이다.  

하지만, 비트 연산은 아주 익숙해지기 전에는 사용하기가 헛갈리고, 번거로워 보인다.  

무엇보다 실수하기 쉽고, 실수를 찾기도 어렵다.  

이러한 골칫덩이를 한 방에 해결할 수 있는 것이 바로, **매크로**이다.  

물론 이를 함수로 만들어 사용할 수도 있지만, 이렇게 작은 부분까지 함수로 만들어 사용한다면 성능을
떨어뜨릴 수가 있기 때문에 보통 매크로를 이용한다.  

프로그램에서 많이 사용되는 비트 조작으로는 특정 비트 클리어 및 설정, 비트 반전, 비트 검사, 비트 추출 등이다.  

이들 비트 연산을 다시 정리해보면 다음과 같다.  
```c
unsigned char a = 0xf0; // 0b11110000  
a &= ~(0x1<<5); // 한 비트 클리어(예> 5번 비트)  
a &= ~(0x7<<3); // 연속된 여러 비트 클리어(예> 5, 4, 3번 비트)  
a &= ~((0x1<<5)+(0x3<<2)); // 떨어져 있는 여러 비트 클리어(예> 5, 3, 2번 비트)  

a |= ~(0x1<<5); // 한 비트 설정(예> 5번 비트)  
a |= ~(0x7<<3); // 연속된 여러 비트 설정(예> 5, 4, 3번 비트)  
a |= ~((0x1<<5)+(0x3<<2)); // 떨어져 있는 여러 비트 설정(예> 5, 3, 2번 비트)  

a ^= ~(0x1<<5); // 한 비트 반전(예> 5번 비트)  
a ^= ~(0x7<<3); // 연속된 여러 비트 반전(예> 5, 4, 3번 비트)  
a ^= ~((0x1<<5)+(0x3<<2)); // 떨어져 있는 여러 비트 반전(예> 5, 3, 2번 비트)  

a & (0x1<<5); // 비트 검사 (예> 5번 비트)  

b = (a>>4) & 0x7; // 비트 추출 (예> 6, 5, 4번 비트)  
```

위 비트 연산을 매크로로 만들면 다음과 같다.  
<sub>파일이름: macro.h</sub>  
```c  
// 한비트 클리어
#define clear_bit(data, loc)            ((data) &= ~(0x1<<(loc)))
// 연속된 여러 비트 클리어
#define clear_bits(data, area, loc)     ((data) &= ~((area)<<(loc)))

// 한비트 설정
#define set_bit(data, loc)              ((data) |= ~(0x1<<(loc)))
// 연속된 여러 비트 설정
#define set_bits(data, area, loc)       ((data) |= ~((area)<<(loc)))

// 한비트 반전
#define invert_bit(data, loc)           ((data) ^= ~(0x1<<(loc)))
// 연속된 여러 비트 반전
#define invert_bits(data, area, loc)    ((data) ^= ~((area)<<(loc)))

// 비트 검사 
#define check_bit(data, loc)            ((data) & (0x1<<(loc)))

// 비트 추출
#define extract_bits(data, area, loc)   (((data)>>(loc)) & (area))
```

다음은 매크로를 테스트한 소스이다.  
```c  
#include <stdio.h>
#include "macro.h"

void main (void){
    unsigned char a = 0xf0;
    unsigned char b;

    clear_bit(a, 5);                // 모두 a에 대한 비트 조작
    clear_bits(a, 0x7, 3);          // 5번 비트 클리어

    set_bit(a, 5);                  // 5번 비트 설정
    set_bits(a, 0x7, 3);            // 5, 4, 3번의 연속 3비트 설정

    invert_bit(a, 5);               // 5번 비트 반전
    invert_bits(a, 0x7, 3);         // 5, 4, 3번 연속 3비트 반전

    if(check_bit(a, 5))             // 5번 비트가 어떤 값인지 체크
        printf("true");             // 1이면 1을 반환 0이면 0을 반환
    else                            // 1이면 true를 0이면 false를 출력
        printf("false");

    b = extract_bits(a, 0x7, 4);    // 6, 5, 4번 비트를 추출하여 b에 대입
}
```
위 소스에서 보는 것 처럼 매크로를 이용하면 매번 비트 연산을 할 때마다 고민할 필요가 없다.   

하지만 편히나 매크로에는 빠지기 쉬운 함정이 있다. 바로 **치환 함정**이다.  

다음은 입력받은 수를 더하는 매크로이다.  
```c
#define ADD(x)          X+X

void main(void){
    int k;
    k = -ADD(5);
}
```
위의 소스는 두수의 합을 음수화 시키고자하는 소스이다. 그런데 k를 출력해 보면 0이 출력된다.  

수식을 치환해보면 `k=-5+5`이 되기 때문이다.  

그렇다면 정상적으로 작동시키려면 어떻게 해야할까?  

매크로의 수식을 괄호로 묶어주어야 한다.  
```c
#define ADD(X)          (X+X)
```

하지만 이 매크로도 잘못됬다. 다음을 살펴보면,  
```c
#include <stdio.h>
#include SQUARE(X)      (X*X) 

void main(void){
    int a = 2;
    printf("%d", SQUARE(a + 5))
}
```
원하는 수식은 `(a+5)*(a+5)`이지만 이번 소스의 수식을 치환해 보면 `a+(5*a)+5`가 된다.  

최종적으로 이 코드를 수정하면,  
```c
#define SQUARE(X)       ((X)*(X))
```
정리해보면, 매크로는 각 인자를 괄호로 묶어주고, 전체 수식 또한 괄호로 묶어주어야 한다.  

쉽지만, 자주 일어나는 실수이며, 나중에 버그를 찾기도 어렵다. 매크로는 괄호가 중요하다.  

<sub>
내용 참고: 임베디드 프로그래밍 C코드 최적화(Blog2Book)
</sub>

<a href="#page-title" class="back-to-top">{{ site.data.ui-text[site.locale].back_to_top | default: 'Back to Top' }} &uarr;</a>
